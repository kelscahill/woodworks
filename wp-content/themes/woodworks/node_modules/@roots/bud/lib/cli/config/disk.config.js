import { __decorate } from "tslib";
import { bind } from 'helpful-decorators';
import { isFunction, isObject } from 'lodash-es';
/**
 * User config parser
 *
 * @public
 */
class Configuration {
    /**
     * Class constructor
     *
     * @public
     */
    constructor(app, manifests) {
        this.app = app;
        this.manifests = manifests;
        /**
         * Manifest
         *
         * @public
         */
        this.manifest = {};
        manifests &&
            Object.values(manifests)
                .filter(config => config?.name?.includes('bud.config'))
                .map(config => {
                this.manifest[config.name] = config.module;
            });
        Object.keys(this.manifest).map(k => this.app.info({ message: `Received config: ${k}` }));
    }
    /**
     * Process configuration
     *
     * @public
     * @decorator `@bind`
     */
    async run() {
        await Promise.all(Object.entries(this.manifest).map(async ([name, config]) => {
            this.app.info({ message: `Processing config: ${name}` });
            if (!isFunction(config) && !isObject(config))
                return this.app.error(`bud tried to parse ${name ?? 'unknown file'} but it doesn't seem to be a function or an object config`);
            isFunction(config)
                ? await config(this.app)
                : await this.processStatic(config);
        }));
    }
    /**
     * Process static configuration
     *
     * @public
     * @decorator `@bind`
     */
    async processStatic(config) {
        await Promise.all(Object.entries(config).map(async ([key, value]) => {
            const request = this.app[key];
            if (isFunction(request))
                await request(value);
        }));
    }
}
__decorate([
    bind
], Configuration.prototype, "run", null);
__decorate([
    bind
], Configuration.prototype, "processStatic", null);
/**
 * Process dynamic configuration
 *
 * @public
 */
export const config = async (app) => {
    const process = async (manifests) => {
        await app.api.processQueue();
        await new Configuration(app, manifests).run();
        await app.api.processQueue();
    };
    const baseConfig = app.project.get(`config.base`);
    await process(baseConfig);
    const modeSpecific = app.project.get(`config.${app.mode}`);
    await process(modeSpecific);
    try {
        await Promise.all(Object.values(app.services)
            .filter(service => isFunction(service.afterConfig))
            .map(async (service) => {
            await service.afterConfig(app);
        }));
        await app.hooks.fire('config.after');
    }
    catch (err) {
        app.error(err);
    }
};
//# sourceMappingURL=disk.config.js.map