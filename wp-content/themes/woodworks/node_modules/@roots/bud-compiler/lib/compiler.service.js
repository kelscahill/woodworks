import { __decorate } from "tslib";
import { Service } from '@roots/bud-framework';
import { bind, once } from 'helpful-decorators';
import { isFunction } from 'lodash-es';
import Webpack from 'webpack';
import * as Reporter from './Reporter/index.js';
/**
 * Wepback compilation controller class
 *
 * @public
 */
export class Compiler extends Service {
    constructor() {
        super(...arguments);
        /**
         * Compiler implementation
         *
         * @internal
         */
        this._implementation = Webpack;
        /**
         * Compilation stats
         *
         * @public
         */
        this.stats = {
            json: null,
            string: null,
        };
        /**
         * Errors
         *
         * @public
         */
        this.errors = [];
        /**
         * Warnings
         *
         * @public
         */
        this.warnings = [];
        /**
         * Multi-compiler configuration
         *
         * @public
         */
        this.config = [];
        this.done = false;
        this.compiling = false;
    }
    /**
     * Compiler implementation
     *
     * @public
     */
    get implementation() {
        return this._implementation;
    }
    set implementation(implementation) {
        this._implementation = implementation;
    }
    /**
     * Initiates compilation
     *
     * @returns the compiler instance
     *
     * @public
     * @decorator `@bind`
     * @decorator `@once`
     */
    async compile() {
        this.config = await this.before();
        this.app._hrdone = this.app._hrdiff();
        this.compilation = await this.invoke(this.config);
        return this.compilation;
    }
    /**
     * Invoke compiler
     *
     * @public
     * @decorator `@bind`
     * @decorator `@once`
     */
    async invoke(config) {
        await this.app.hooks.fire('compiler.before');
        this.compilation = this.implementation(config ?? this.config);
        this.app.isDevelopment &&
            this.compilation.hooks.done.tap(`${this.app.name}-dev-handle`, async (stats) => {
                this.handleStats(stats);
            });
        this.compilation.hooks.done.tap(`${this.app.name}-cli-done`, async () => await this.app.hooks.fire('compiler.close'));
        new Webpack.ProgressPlugin(this.app.dashboard.progressCallback).apply(this.compilation);
        await this.app.hooks.fire('compiler.after');
        return this.compilation;
    }
    /**
     * Returns final webpack configuration
     *
     * @public
     * @decorator `@bind`
     */
    async before() {
        if (!this.app.hasChildren) {
            await this.app.build.make();
            this.config.push(this.app.build.config);
            return this.config;
        }
        await Promise.all(Object.entries(this.app.children).map(async ([name, instance]) => {
            const config = await instance.build.make();
            this.app.log(`child config`, name, config);
            this.config.push(config);
            return Promise.resolve();
        }));
        this.app.log(this.config);
        return this.config;
    }
    /**
     * Webpack callback
     *
     * @public
     * @decorator `@bind`
     * @decorator `@once`
     */
    callback(error, stats) {
        if (error)
            this.onError(error);
        if (stats)
            this.handleStats(stats);
    }
    /**
     * Stats handler
     *
     * @public
     * @decorator `@bind`
     */
    handleStats(stats) {
        if (!stats?.toJson || !isFunction(stats?.toJson))
            return;
        this.stats.json = stats.toJson();
        this.stats.string = stats.toString();
        const problemReporter = Reporter.report(this.app, this.stats.json);
        this.errors = problemReporter.errors;
        this.warnings = problemReporter.warnings;
        this.app.dashboard.stats({
            stats: this.stats.json,
            errors: this.errors,
            warnings: this.warnings,
        });
        this.app.isProduction && this.compilation.close(this.onClose);
    }
    /**
     * Compiler close event
     *
     * @public
     * @decorator `@bind`
     */
    onClose(error) {
        if (error)
            return this.onError(error);
        this.app.isProduction && this.app.close();
    }
    /**
     * Compiler error event
     *
     * @public
     * @decorator `@bind`
     */
    onError(error) {
        this.app.isDevelopment &&
            this.app.server.appliedMiddleware?.hot?.publish({ error });
        this.app.error(error);
    }
}
__decorate([
    bind,
    once
], Compiler.prototype, "compile", null);
__decorate([
    bind,
    once
], Compiler.prototype, "invoke", null);
__decorate([
    bind
], Compiler.prototype, "before", null);
__decorate([
    bind,
    once
], Compiler.prototype, "callback", null);
__decorate([
    bind
], Compiler.prototype, "handleStats", null);
__decorate([
    bind
], Compiler.prototype, "onClose", null);
__decorate([
    bind
], Compiler.prototype, "onError", null);
//# sourceMappingURL=compiler.service.js.map