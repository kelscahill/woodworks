import { __decorate } from "tslib";
import { Service } from '@roots/bud-framework/service';
import Express from 'express';
import { bind, once } from 'helpful-decorators';
import { inject } from '../inject.js';
import * as middlewareMap from '../middleware/index.js';
import { seed } from '../seed.js';
import { Http } from './server.http.js';
import { Https } from './server.https.js';
import { Watcher } from './server.watcher.js';
/**
 * Server service class
 * @public
 */
export class Server extends Service {
    constructor() {
        super(...arguments);
        /**
         * Express instance
         * @public
         */
        this.express = Express;
        /**
         * Available middleware
         * @public
         */
        this.availableMiddleware = middlewareMap;
        /**
         * Applied middleware
         * @public
         */
        this.appliedMiddleware = {};
    }
    /**
     * Utilized middleware
     * @public
     */
    get enabledMiddleware() {
        return this.app.hooks.filter('dev.middleware.enabled').reduce((enabled, key) => ({
            ...enabled,
            [key]: this.availableMiddleware[key],
        }), {});
    }
    /**
     * Register service
     * @public
     * @decorator `@bind`
     * @decorator `@once`
     */
    async register() {
        if (!this.app.isDevelopment)
            return;
        seed(this.app);
        this.application = this.express();
        this.application.set('x-powered-by', false);
        this.watcher = new Watcher(this.app);
    }
    /**
     * Boot service
     * @public
     * @decorator `@bind`
     * @decorator `@once`
     */
    async boot() {
        if (!this.app.isDevelopment)
            return;
        this.app.hooks.action('server.before', this.setConnection, this.injectScripts, this.app.compiler.compile, this.applyMiddleware);
        this.app.hooks.action('server.after', this.watcher.watch);
    }
    /**
     * Set connection
     * @public
     * @decorator `@bind`
     * @decorator `@once`
     */
    async setConnection() {
        this.connection =
            this.app.hooks.filter('dev.url').protocol === 'https:'
                ? new Https(this.app)
                : new Http(this.app);
        await this.connection.setup();
    }
    /**
     * Inject scripts
     * @public
     * @decorator `@bind`
     * @decorator `@once`
     */
    async injectScripts() {
        this.app.log('injecting client scripts');
        const injectOn = (instance) => inject(instance, Array.from(this.app.hooks.filter('dev.client.scripts') ?? new Set([])));
        this.app.hasChildren
            ? Object.values(this.app.children).map(injectOn)
            : injectOn(this.app);
    }
    /**
     * Apply middleware
     * @public
     * @decorator `@bind`
     * @decorator `@once`
     */
    async applyMiddleware() {
        Object.entries(this.enabledMiddleware).map(([key, middleware]) => {
            this.appliedMiddleware[key] = middleware(this.app);
            this.application.use(this.appliedMiddleware[key]);
        });
    }
    /**
     * Run development server
     * @public
     * @decorator `@bind`
     */
    async run() {
        await this.app.hooks.fire('server.before');
        await this.connection.createServer(this.application);
        await this.connection.listen();
        await this.app.hooks.fire('server.after');
    }
}
__decorate([
    bind,
    once
], Server.prototype, "register", null);
__decorate([
    bind,
    once
], Server.prototype, "boot", null);
__decorate([
    bind,
    once
], Server.prototype, "setConnection", null);
__decorate([
    bind,
    once
], Server.prototype, "injectScripts", null);
__decorate([
    bind,
    once
], Server.prototype, "applyMiddleware", null);
__decorate([
    bind
], Server.prototype, "run", null);
//# sourceMappingURL=index.js.map