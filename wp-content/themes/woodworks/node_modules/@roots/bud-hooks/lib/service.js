import { __decorate } from "tslib";
import * as Framework from '@roots/bud-framework';
import { bind } from 'helpful-decorators';
import { isFunction, isUndefined } from 'lodash-es';
/**
 * Hooks and events registry
 *
 * @remarks
 * Supports async and sync value hooks as well as asyncronous events.
 *
 * @example
 * Add a new entry to the `webpack.externals` configuration:
 *
 * ```ts
 * hooks.on(
 *   'build.externals',
 *   externals => ({
 *     ...externals,
 *     $: 'jquery',
 *   }),
 * )
 * ```
 *
 * @example
 * Change the `webpack.output.filename` format:
 *
 * ```ts
 * hooks.on(
 *   'build.output.filename',
 *   () => '[name].[hash:4]',
 * )
 * ```
 *
 * @example
 * Filter a value through any registered hooks:
 *
 * ```ts
 * hooks.filter('build.output.filename', DEFAULT_VALUE)
 * ```
 *
 * @example
 * Filter an async value through any registered hooks:
 *
 * ```ts
 * await hooks.filterAsync('my-event-name', async () => DEFAULT_VALUE)
 * ```
 *
 * @public
 */
export default class Hooks extends Framework.Service {
    constructor() {
        super(...arguments);
        /**
         * Hooks store
         *
         * @public
         */
        this.store = null;
    }
    /**
     * Class constructor
     *
     * @param app - Bud instance
     * @public
     */
    async bootstrap(app) {
        this.store = isFunction(app.options.seed)
            ? { ...app.options.seed(app) }
            : { ...app.options.seed };
    }
    /**
     * Get stored value
     *
     * @internal
     * @decorator `@bind`
     */
    get(path) {
        if (!this.store[path])
            this.store[path] = [];
        return this.store[path];
    }
    /**
     * Set stored value
     *
     * @internal
     * @decorator `@bind`
     */
    set(path, value) {
        if (this.store[path])
            this.store[path] = [...this.store[path], ...value];
        else
            this.store[path] = value;
        return this;
    }
    /**
     * Not type safe but very convenient
     * to check if a hook has been set somewhere
     */
    has(path) {
        return !isUndefined(this.store[path]) ? true : false;
    }
    /**
     * Register a function to filter a value.
     *
     * @remarks
     * If a filter calls for this name the function is then run,
     * passing whatever data along for modification. If more than one
     * hook is registered to a name, they will be called sequentially
     * in the order they were registered, with each hook's output used
     * as the input for the next.
     *
     * @example
     * ```js
     * app.hooks.on(
     *   'namespace.key',
     *   value => 'replaced by this string',
     * )
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    on(id, input) {
        const inputFn = typeof input === 'function' ? input : () => input;
        this.app.info(`hooks.on`, id, input);
        this.set(id, [inputFn]);
        return this.app;
    }
    /**
     * Register a function to filter a value.
     *
     * @remarks
     * If a filter calls for this name the function is then run,
     * passing whatever data along for modification. If more than one
     * hook is registered to a name, they will be called sequentially
     * in the order they were registered, with each hook's output used
     * as the input for the next.
     *
     * @example
     * ```js
     * app.hooks.on(
     *   'namespace.key',
     *   value => 'replaced by this string',
     * )
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    async(id, input) {
        const inputFn = typeof input === 'function' ? input : async () => input;
        this.app.info(`hooks.async`, id, input);
        this.set(id, [inputFn]);
        return this.app;
    }
    /**
     * Filter sync value
     *
     * @remarks
     * Will filter a sync value
     *
     * @example
     * ```js
     * bud.hooks.filter(
     *   'namespace.Key.event',
     *   ['array', 'of', 'items'],
     * )
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    filter(id, fallback) {
        if (!this.has(id))
            return isFunction(fallback) ? fallback() : fallback;
        const result = (this.store[id] ?? []).reduce((accumulated, current) => current(accumulated), isFunction(fallback) ? fallback() : fallback);
        this.app.info(`hooks.filter`, id, result);
        return result;
    }
    /**
     * Asyncronous hook filter
     *
     * @remarks
     * This method is used to filter a hook event.
     *
     * @example
     * ```js
     * bud.hooks.filter(
     *   'namespace.Key.event',
     *   ['array', 'of', 'items'],
     * )
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    async filterAsync(id, fallback) {
        if (!this.has(id))
            return isFunction(fallback) ? await fallback() : fallback;
        const result = await (this.store[id] ?? []).reduce(async (accumulated, current) => {
            const next = await accumulated;
            return isFunction(current) ? await current(next) : current;
        }, fallback);
        this.app.info(`hooks.filterAsync`, id, result);
        return result;
    }
    /**
     * Register an action (called with {@link Hooks.fire})
     *
     * @public
     * @decorator `@bind`
     */
    action(id, ...actions) {
        const value = this.store[id] ?? [];
        actions.forEach(action => value.push(action));
        this.app.info({ message: `registering action: ${id}` });
        this.set(id, value);
        return this.app;
    }
    /**
     * Fire actions registered to an event.
     *
     * @example
     * ```js
     * await app.hooks.fire('namespace.key')
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    async fire(id) {
        if (!this.has(id))
            return;
        const retrieved = this.get(id);
        await retrieved.reduce(async (promise, current) => {
            await promise;
            this.app.info(`firing action ${id}`);
            return current(this.app);
        }, Promise.resolve());
        return this.app;
    }
}
__decorate([
    bind
], Hooks.prototype, "get", null);
__decorate([
    bind
], Hooks.prototype, "set", null);
__decorate([
    bind
], Hooks.prototype, "has", null);
__decorate([
    bind
], Hooks.prototype, "on", null);
__decorate([
    bind
], Hooks.prototype, "async", null);
__decorate([
    bind
], Hooks.prototype, "filter", null);
__decorate([
    bind
], Hooks.prototype, "filterAsync", null);
__decorate([
    bind
], Hooks.prototype, "action", null);
__decorate([
    bind
], Hooks.prototype, "fire", null);
//# sourceMappingURL=service.js.map