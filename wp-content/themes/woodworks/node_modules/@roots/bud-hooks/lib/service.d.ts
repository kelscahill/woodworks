import * as Framework from '@roots/bud-framework';
/**
 * Hooks and events registry
 *
 * @remarks
 * Supports async and sync value hooks as well as asyncronous events.
 *
 * @example
 * Add a new entry to the `webpack.externals` configuration:
 *
 * ```ts
 * hooks.on(
 *   'build.externals',
 *   externals => ({
 *     ...externals,
 *     $: 'jquery',
 *   }),
 * )
 * ```
 *
 * @example
 * Change the `webpack.output.filename` format:
 *
 * ```ts
 * hooks.on(
 *   'build.output.filename',
 *   () => '[name].[hash:4]',
 * )
 * ```
 *
 * @example
 * Filter a value through any registered hooks:
 *
 * ```ts
 * hooks.filter('build.output.filename', DEFAULT_VALUE)
 * ```
 *
 * @example
 * Filter an async value through any registered hooks:
 *
 * ```ts
 * await hooks.filterAsync('my-event-name', async () => DEFAULT_VALUE)
 * ```
 *
 * @public
 */
export default class Hooks extends Framework.Service implements Framework.Hooks.Service {
    /**
     * Hooks store
     *
     * @public
     */
    store: Framework.Store;
    /**
     * Class constructor
     *
     * @param app - Bud instance
     * @public
     */
    bootstrap(app: Framework.Bud): Promise<void>;
    /**
     * Get stored value
     *
     * @internal
     * @decorator `@bind`
     */
    get<T extends `${keyof Framework.Store & string}`>(path: T): Framework.Store[T];
    /**
     * Set stored value
     *
     * @internal
     * @decorator `@bind`
     */
    set<T extends keyof Framework.Store>(path: T & string, value: Framework.Store[T & string]): this;
    /**
     * Not type safe but very convenient
     * to check if a hook has been set somewhere
     */
    has<T extends `${keyof Framework.Store & string}`>(path: T): boolean;
    /**
     * Register a function to filter a value.
     *
     * @remarks
     * If a filter calls for this name the function is then run,
     * passing whatever data along for modification. If more than one
     * hook is registered to a name, they will be called sequentially
     * in the order they were registered, with each hook's output used
     * as the input for the next.
     *
     * @example
     * ```js
     * app.hooks.on(
     *   'namespace.key',
     *   value => 'replaced by this string',
     * )
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    on<T extends `${keyof Framework.Registry.Sync & string}`>(id: T, input: Framework.Registry.Sync[T] | ((current?: Framework.Registry.Sync[T]) => Framework.Registry.Sync[T])): Framework.Bud;
    /**
     * Register a function to filter a value.
     *
     * @remarks
     * If a filter calls for this name the function is then run,
     * passing whatever data along for modification. If more than one
     * hook is registered to a name, they will be called sequentially
     * in the order they were registered, with each hook's output used
     * as the input for the next.
     *
     * @example
     * ```js
     * app.hooks.on(
     *   'namespace.key',
     *   value => 'replaced by this string',
     * )
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    async<T extends `${keyof Framework.Registry.Async & string}`>(id: T, input: Framework.Registry.Async[T] | ((current?: Framework.Registry.Async[T]) => Promise<Framework.Registry.Async[T]>)): Framework.Bud;
    /**
     * Filter sync value
     *
     * @remarks
     * Will filter a sync value
     *
     * @example
     * ```js
     * bud.hooks.filter(
     *   'namespace.Key.event',
     *   ['array', 'of', 'items'],
     * )
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    filter<T extends keyof Framework.Registry.Sync & string>(id: T, fallback?: Framework.Registry.Sync[T] | ((value?: Framework.Registry.Sync[T]) => Framework.Registry.Sync[T])): Framework.Registry.Sync[T];
    /**
     * Asyncronous hook filter
     *
     * @remarks
     * This method is used to filter a hook event.
     *
     * @example
     * ```js
     * bud.hooks.filter(
     *   'namespace.Key.event',
     *   ['array', 'of', 'items'],
     * )
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    filterAsync<T extends keyof Framework.Registry.Async>(id: T & string, fallback?: Framework.Registry.Async[T & string]): Promise<Framework.Registry.Async[T & string]>;
    /**
     * Register an action (called with {@link Hooks.fire})
     *
     * @public
     * @decorator `@bind`
     */
    action<T extends keyof Framework.Registry.Events & keyof Framework.Store & string>(id: T, ...actions: Array<(app?: Framework.Bud) => Promise<unknown>>): Framework.Bud;
    /**
     * Fire actions registered to an event.
     *
     * @example
     * ```js
     * await app.hooks.fire('namespace.key')
     * ```
     *
     * @public
     * @decorator `@bind`
     */
    fire<T extends keyof Framework.Registry.Events & keyof Framework.Store & string>(id: T): Promise<Framework.Bud>;
}
//# sourceMappingURL=service.d.ts.map