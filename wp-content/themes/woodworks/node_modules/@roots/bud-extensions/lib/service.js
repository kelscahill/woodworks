import { __decorate } from "tslib";
import { Extension, Service, } from '@roots/bud-framework';
import { bind } from 'helpful-decorators';
/**
 * Extensions Service
 *
 * @public
 */
export default class Extensions extends Service {
    constructor() {
        super(...arguments);
        /**
         * Service store
         *
         * @public
         */
        this.repository = {};
        /**
      -   * Modules on which an import
      -   * attempt was made and failed
      -   *
      -   * @remarks
      -   * This doesn't mean an error, per se. This should only
      -   * be used in the text of trying to import `optionalDependencies`
      -   * of a given extension module.
      -   *
      -   * @public
      -   */
        this.unresolvable = new Set();
    }
    /**
     * `booted` callback
     *
     * @public
     * @decorator `@bind`
     */
    async booted() {
        ;
        [...this.app.options.extensions].map(this.instantiate).map(this.set);
        await this.injectExtensions();
        await this.runAll('_init');
        await this.runAll('_register');
        await this.runAll('_boot');
    }
    /**
     * `afterConfig` callback
     *
     * @public
     * @decorator `@bind`
     */
    async afterConfig() {
        await this.runAll('_afterConfig');
    }
    /**
     * Has extension
     *
     * @public
     * @decorator `@bind`
     */
    has(key, ...iterable) {
        return this.repository[key] ? true : false;
    }
    /**
     * Get extension
     *
     * @public
     * @decorator `@bind`
     */
    get(key) {
        return this.repository[key];
    }
    /**
     * Remove extension
     *
     * @public
     * @decorator `@bind`
     */
    remove(key) {
        delete this.repository[key];
        return this;
    }
    /**
     * Set extension
     *
     * @public
     * @decorator `@bind`
     */
    set(value) {
        this.repository[value.label] = value;
        return this;
    }
    /**
     * Instantiate a Framework extension class or object
     *
     * @public
     * @decorator `@bind`
     */
    instantiate(extension) {
        return typeof extension === 'function'
            ? new extension(this.app)
            : !(extension instanceof Extension)
                ? new Extension(this.app).fromObject(extension)
                : extension;
    }
    filterApplicableExtensions(extensions) {
        return extensions
            .filter(signifier => !this.has(signifier))
            .filter(signifier => signifier.startsWith('@roots/bud-') ||
            signifier.startsWith('@roots/sage') ||
            signifier.startsWith('bud-'))
            .filter(signifier => ![
            '@roots/bud-api',
            '@roots/bud-build',
            '@roots/bud-cache',
            '@roots/bud-client',
            '@roots/bud-compiler',
            '@roots/bud-dashboard',
            '@roots/bud-extensions',
            '@roots/bud-framework',
            '@roots/bud-hooks',
            '@roots/bud-server',
        ].includes(signifier))
            .filter(signifier => !this.app.context.manifest.bud?.denylist ||
            !this.app.context.manifest.bud?.denylist.includes(signifier))
            .filter(signifier => !this.app.context.manifest.bud?.allowlist ||
            this.app.context.manifest.bud?.allowlist.includes(signifier));
    }
    /**
     * Automatically instantiate and register extensions
     * located from the project `package.json` manifest
     *
     * @public
     * @decorator `@bind`
     */
    async injectExtensions() {
        if (this.app.hooks.filter('feature.inject') === false) {
            return this.app.log('injection disabled');
        }
        this.app.log('injecting extensions...');
        await this.filterApplicableExtensions(Object.keys({
            ...(this.app.context.manifest?.devDependencies ?? {}),
            ...(this.app.context.manifest?.dependencies ?? {}),
        })).reduce(async (promised, signifier) => {
            await promised;
            try {
                this.app.log('...importing', signifier);
                await this.import(signifier);
            }
            catch (error) {
                this.app.warn(`Error importing`, signifier, `\n`, error);
            }
        }, Promise.resolve());
    }
    /**
     * Import an extension
     *
     * @public
     * @decorator `@bind`
     */
    async import(signifier) {
        if (this.has(signifier) ||
            !this.filterApplicableExtensions([signifier]).length)
            return;
        const extension = await this.app.module.import(signifier);
        const instance = this.instantiate(extension);
        instance.dependsOn &&
            (await this.filterApplicableExtensions(Array.from(instance.dependsOn)).reduce(async (promised, signifier) => {
                await promised;
                if (this.has(signifier))
                    return;
                await this.import(signifier);
                if (!this.has(signifier)) {
                    this.unresolvable.add(signifier);
                    this.app.error(`missing dependency`, signifier);
                }
            }, Promise.resolve()));
        instance.dependsOnOptional &&
            (await this.filterApplicableExtensions(Array.from(instance.dependsOnOptional)).reduce(async (promised, signifier) => {
                try {
                    await promised;
                    if (this.has(signifier) || this.unresolvable.has(signifier))
                        return;
                    await this.import(signifier);
                    if (!this.has(signifier))
                        this.unresolvable.add(signifier);
                }
                catch (err) { }
            }, Promise.resolve()));
        this.set(instance);
        return extension;
    }
    /**
     * Run an extension lifecycle method
     *
     * @remarks
     * - `_init`
     * - `_register`
     * - `_boot`
     * - `_beforeBuild`
     * - `_make`
     *
     * @public
     * @decorator `@bind`
     */
    async run(extension, methodName) {
        if (extension.meta[methodName] === true)
            return this;
        else
            extension.meta[methodName] = true;
        try {
            await this.runDependencies(extension, methodName);
            if (!extension[methodName.replace('_', '')])
                return this;
            await extension[methodName]();
            await this.app.api.processQueue();
            return this;
        }
        catch (err) {
            this.app.error(err);
        }
    }
    /**
     * Run a lifecycle method for an extension's dependencies
     *
     * @remarks
     * Called from {@link Extension.run}. Ensures a method is run for an
     * extension's dependencies before it is run for the extension itself.
     *
     * @public
     * @decorator `@bind`
     */
    async runDependencies(extension, methodName) {
        extension =
            typeof extension === 'string' ? this.get(extension) : extension;
        if (extension.dependsOn && extension.dependsOn.size > 0) {
            await Array.from(extension.dependsOn).reduce(async (promised, signifier) => {
                await promised;
                try {
                    if (!this.has(signifier))
                        await this.import(signifier);
                    if (!this.get(signifier).meta[methodName])
                        await this.run(this.get(signifier), methodName);
                }
                catch (error) {
                    this.app.error(error);
                }
            }, Promise.resolve());
        }
        if (extension.dependsOnOptional &&
            extension.dependsOnOptional.size > 0) {
            await Array.from(extension.dependsOnOptional).reduce(async (promised, dependency) => {
                await promised;
                try {
                    if (!this.has(dependency))
                        await this.import(dependency);
                    await this.run(this.get(dependency), methodName);
                }
                catch (error) { }
            }, Promise.resolve());
        }
    }
    /**
     * Execute a extension lifecycle method on all registered extensions
     *
     * @public
     * @decorator `@bind`
     */
    async runAll(methodName) {
        return await Object.values(this.repository).reduce(async (promised, extension) => {
            await promised;
            await this.run(extension, methodName);
        }, Promise.resolve());
    }
    /**
     * Add a {@link Extension} to the extensions repository
     *
     * @public
     * @decorator `@bind`
     */
    async add(input) {
        const arrayed = Array.isArray(input) ? input : [input];
        await arrayed.reduce(async (promised, extensionObject) => {
            await promised;
            try {
                const extension = this.instantiate(extensionObject);
                if (this.has(extension.label))
                    return;
                this.set(extension);
                await this.run(extension, '_init');
                await this.run(extension, '_register');
                await this.run(extension, '_boot');
                return Promise.resolve();
            }
            catch (err) {
                this.app.error(err);
                return Promise.reject();
            }
        }, Promise.resolve());
    }
    /**
     * Returns an array of plugin instances which have been registered to the
     * container and are set to be used in the compilation
     *
     * @returns An array of plugin instances
     *
     * @public
     * @decorator `@bind`
     */
    async make() {
        return await Promise.all(Object.values(this.repository).map(async (extension) => await extension._make())).then((result) => result.filter(Boolean));
    }
}
__decorate([
    bind
], Extensions.prototype, "booted", null);
__decorate([
    bind
], Extensions.prototype, "afterConfig", null);
__decorate([
    bind
], Extensions.prototype, "has", null);
__decorate([
    bind
], Extensions.prototype, "get", null);
__decorate([
    bind
], Extensions.prototype, "remove", null);
__decorate([
    bind
], Extensions.prototype, "set", null);
__decorate([
    bind
], Extensions.prototype, "instantiate", null);
__decorate([
    bind
], Extensions.prototype, "filterApplicableExtensions", null);
__decorate([
    bind
], Extensions.prototype, "injectExtensions", null);
__decorate([
    bind
], Extensions.prototype, "import", null);
__decorate([
    bind
], Extensions.prototype, "run", null);
__decorate([
    bind
], Extensions.prototype, "runDependencies", null);
__decorate([
    bind
], Extensions.prototype, "runAll", null);
__decorate([
    bind
], Extensions.prototype, "add", null);
__decorate([
    bind
], Extensions.prototype, "make", null);
//# sourceMappingURL=service.js.map