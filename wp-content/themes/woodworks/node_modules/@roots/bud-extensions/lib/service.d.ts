import { Extension, Extensions as Contract, Modules, Service } from '@roots/bud-framework';
import type { ApplyPlugin, ExtensionLiteral } from '@roots/bud-framework/src/extension';
/**
 * Extensions Service
 *
 * @public
 */
export default class Extensions extends Service implements Contract.Service {
    /**
     * Service store
     *
     * @public
     */
    repository: Modules;
    /**
  -   * Modules on which an import
  -   * attempt was made and failed
  -   *
  -   * @remarks
  -   * This doesn't mean an error, per se. This should only
  -   * be used in the text of trying to import `optionalDependencies`
  -   * of a given extension module.
  -   *
  -   * @public
  -   */
    unresolvable: Set<unknown>;
    /**
     * `booted` callback
     *
     * @public
     * @decorator `@bind`
     */
    booted(): Promise<void>;
    /**
     * `afterConfig` callback
     *
     * @public
     * @decorator `@bind`
     */
    afterConfig(): Promise<void>;
    /**
     * Has extension
     *
     * @public
     * @decorator `@bind`
     */
    has<K extends keyof Modules>(key: K & string, ...iterable: any[]): boolean;
    /**
     * Get extension
     *
     * @public
     * @decorator `@bind`
     */
    get<K extends keyof Modules>(key: K & string): Extension<any, any>;
    /**
     * Remove extension
     *
     * @public
     * @decorator `@bind`
     */
    remove<K extends keyof Modules>(key: K & string): this;
    /**
     * Set extension
     *
     * @public
     * @decorator `@bind`
     */
    set<K extends Modules>(value: Modules[K & string]): this;
    /**
     * Instantiate a Framework extension class or object
     *
     * @public
     * @decorator `@bind`
     */
    instantiate<K extends Modules>(extension: (new (...args: any[]) => Modules[K & string]) | ExtensionLiteral): Modules[K & string];
    protected filterApplicableExtensions(extensions: Array<string>): Array<string>;
    /**
     * Automatically instantiate and register extensions
     * located from the project `package.json` manifest
     *
     * @public
     * @decorator `@bind`
     */
    injectExtensions(): Promise<import("@roots/bud-framework/src").Bud>;
    /**
     * Import an extension
     *
     * @public
     * @decorator `@bind`
     */
    import(signifier: string): Promise<Extension>;
    /**
     * Run an extension lifecycle method
     *
     * @remarks
     * - `_init`
     * - `_register`
     * - `_boot`
     * - `_beforeBuild`
     * - `_make`
     *
     * @public
     * @decorator `@bind`
     */
    run<K extends Modules>(extension: Modules[K & string], methodName: '_init' | '_register' | '_boot' | '_afterConfig' | '_beforeBuild' | '_make'): Promise<this>;
    /**
     * Run a lifecycle method for an extension's dependencies
     *
     * @remarks
     * Called from {@link Extension.run}. Ensures a method is run for an
     * extension's dependencies before it is run for the extension itself.
     *
     * @public
     * @decorator `@bind`
     */
    runDependencies<K extends Modules>(extension: Modules[K & string] | (keyof Modules & string), methodName: '_init' | '_register' | '_boot' | '_afterConfig' | '_beforeBuild' | '_make'): Promise<void>;
    /**
     * Execute a extension lifecycle method on all registered extensions
     *
     * @public
     * @decorator `@bind`
     */
    runAll(methodName: '_init' | '_register' | '_boot' | '_afterConfig' | '_beforeBuild' | '_make'): Promise<any>;
    /**
     * Add a {@link Extension} to the extensions repository
     *
     * @public
     * @decorator `@bind`
     */
    add(input: (new (...args: any[]) => Extension) | ExtensionLiteral | Array<(new (...args: any[]) => Extension) | ExtensionLiteral>): Promise<void>;
    /**
     * Returns an array of plugin instances which have been registered to the
     * container and are set to be used in the compilation
     *
     * @returns An array of plugin instances
     *
     * @public
     * @decorator `@bind`
     */
    make(): Promise<ApplyPlugin[]>;
}
//# sourceMappingURL=service.d.ts.map