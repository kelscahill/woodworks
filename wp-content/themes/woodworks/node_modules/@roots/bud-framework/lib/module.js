import { __decorate } from "tslib";
import { bind, memo } from 'helpful-decorators';
import { resolve } from 'import-meta-resolve';
import { createRequire } from 'module';
import { join, normalize, relative } from 'node:path';
/**
 * Module resolver
 *
 * @public
 */
export class Module {
    /**
     * Class constructor
     *
     * @public
     */
    constructor(app) {
        this.app = app;
        this.require = createRequire(this.app.root.context.dir);
    }
    /**
     * Get `package.json` absolute path from a module signifier
     *
     * @public
     * @decorator `@bind`
     */
    async getDirectory(signifier, parent) {
        return await this.resolve(signifier, parent)
            .then(path => path.replace('file://', ''))
            .then(this.require.resolve)
            .then(path => relative(parent ?? this.app.root.context.dir, path))
            .then(path => path.split(signifier).shift())
            .then(path => this.app.path(path, signifier));
    }
    /**
     * Get `package.json` absolute path from a module signifier
     *
     * @public
     * @decorator `@bind`
     */
    async getManifestPath(pkgName) {
        return await this.getDirectory(pkgName).then(dir => join(dir, 'package.json'));
    }
    /**
     * Read `package.json` manifest from a module signifier
     *
     * @public
     * @decorator `@bind`
     */
    async readManifest(signifier) {
        return await this.getManifestPath(signifier).then(async (path) => {
            this.app.log(signifier, `manifest resolved to`, path);
            return await this.app.json.read(path);
        });
    }
    /**
     * Resolve a module path from its signifier
     *
     * @public
     * @decorator `@bind`
     */
    async resolve(signifier, parent) {
        const context = parent ?? `file://${this.app.root.path('./package.json')}`;
        try {
            const resolvedPath = await resolve(signifier, context);
            const normalized = normalize(resolvedPath.replace('file://', '').replace(/%20/g, ' '));
            return normalized;
        }
        catch (err) {
            this.app.info(signifier, 'not resolvable', `(context: ${context})`);
        }
    }
    /**
     * Import a module from its signifier
     *
     * @public
     * @decorator `@bind`
     */
    async import(signifier, context) {
        if (!context)
            context = `file://${this.app.root.path('./package.json')}`;
        const modulePath = await this.resolve(signifier, context);
        const result = await import(modulePath);
        if (!result) {
            this.app.error(signifier, 'not found');
            return {};
        }
        return result?.default ?? result;
    }
}
__decorate([
    bind,
    memo()
], Module.prototype, "getDirectory", null);
__decorate([
    bind,
    memo()
], Module.prototype, "getManifestPath", null);
__decorate([
    bind,
    memo()
], Module.prototype, "readManifest", null);
__decorate([
    bind,
    memo()
], Module.prototype, "resolve", null);
__decorate([
    bind,
    memo()
], Module.prototype, "import", null);
//# sourceMappingURL=module.js.map