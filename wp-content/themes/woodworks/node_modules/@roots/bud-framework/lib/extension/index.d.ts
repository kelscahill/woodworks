import type { Compiler } from 'webpack';
import type { Bud } from '../bud.js';
import type { Modules } from '../registry/index.js';
import type { ApplyPluginConstructor } from './decorators/plugin.js';
export declare type Options<T = any> = {
    [K in keyof T as `${K & string}`]?: T[K];
};
export declare namespace Options {
    type FuncMap<T = any> = Options<{
        [K in keyof T as `${K & string}`]?: (app: Bud) => T[K];
    }>;
    type Seed<T = any> = Options<{
        [K in keyof T as `${K & string}`]?: ((app: Bud) => T[K]) | T[K];
    }>;
}
/**
 * Webpack plugin.
 *
 * @public
 */
export interface ApplyPlugin {
    /**
     * Loose defined
     *
     * @public
     */
    [key: string]: any;
    /**
     * Apply callback
     *
     * @see {@link https://webpack.js.org/contribute/writing-a-plugin/#basic-plugin-architecture}
     *
     * @public
     */
    apply: (compiler?: Compiler) => unknown;
}
export interface Constructor {
    new (...args: [Bud]): Extension;
}
export declare type ExtensionLiteral = {
    [K in keyof Extension]?: Extension[K];
};
/**
 * Bud extension
 *
 * @public
 */
export declare class Extension<E = any, Plugin extends ApplyPlugin = any> {
    /**
     * Application
     *
     * @internal
     */
    _app: () => Bud;
    /**
     * Application accessor
     *
     * @public
     */
    app: Bud;
    /**
     * Extension options
     *
     * @internal
     */
    _options: Options.FuncMap<E>;
    /**
     * Extension options
     *
     * @readonly
     * @public
     */
    readonly options: Options<E>;
    /**
     * Extension meta
     *
     * @public
     */
    meta: {};
    /**
     * The module name
     *
     * @public
     */
    label: keyof Modules & string;
    /**
     * @public
     */
    logger: Bud['logger']['instance'];
    /**
     * Depends on
     *
     * @public
     */
    dependsOn?: Set<`${keyof Modules & string}`>;
    /**
     * Depends on (optional)
     *
     * @public
     */
    dependsOnOptional?: Set<`${keyof Modules & string}`>;
    /**
     * Boolean or a function returning a boolean indicating if the {@link Extension} should be utilized.
     *
     * @remarks
     * If a factory is implemented, it will be passed the {@link Bud} instance as its first parameter and
     * a {@link Container} instance holding the {@link Extension.options} (if any) as the second parameter.
     *
     * @public
     */
    when?(app: Bud, options?: Options<E>): Promise<boolean>;
    /**
     * `init` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     *
     * @public
     */
    init?(app: Bud, options?: Options<E>): Promise<unknown>;
    /**
     * `register` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     *
     * @public
     */
    register?(app: Bud, options?: Options<E>): Promise<unknown>;
    /**
     * `boot` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     *
     * @public
     */
    boot?(app: Bud, options?: Options<E>): Promise<unknown>;
    /**
     * `afterConfig` callback
     *
     * @public
     */
    afterConfig?(app: Bud, options?: Options<E>): Promise<unknown>;
    /**
     * `beforeBuild` callback
     *
     * @public
     */
    beforeBuild?(app: Bud, options?: Options<E>): Promise<unknown>;
    /**
     * `make` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     *
     * @public
     */
    make?(app: Bud, options?: Options<E>): Promise<Plugin>;
    /**
     * Plugin constructor
     *
     * @public
     */
    plugin?: ApplyPluginConstructor;
    /**
     * Compiler plugin `apply` method
     *
     * @public
     */
    apply?: ApplyPlugin['apply'];
    /**
     * Class constructor
     *
     * @public
     */
    constructor(_app: Bud);
    /**
     * `init` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    _init(): Promise<void>;
    /**
     * `register` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    _register(): Promise<void>;
    /**
     * `boot` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    _boot(): Promise<void>;
    /**
     * `beforeBuild` callback handler
     *
     * @public
     */
    _beforeBuild(): Promise<void>;
    /**
     * `beforeBuild` callback handler
     *
     * @public
     */
    _afterConfig(): Promise<void>;
    /**
     * `make` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    _make(): Promise<false | {
        apply: any;
    }>;
    /**
     * Get extension options
     *
     * @public
     * @decorator `@bind`
     */
    getOptions(): Options<E>;
    /**
     * Set extension options
     *
     * @public
     * @decorator `@bind`
     */
    setOptions(value: Options<E> | ((value: Options<E>) => Options<E>)): this;
    /**
     * Get extension option
     *
     * @public
     * @decorator `@bind`
     */
    getOption<K extends keyof Options<E> & string>(key: K): Options<E>[K];
    /**
     * Set extension option
     *
     * @public
     * @decorator `@bind`
     */
    setOption<K extends keyof Options.FuncMap<E>>(key: K & string, value: Options<E>[K & string]): this;
    /**
     * Normalize options to functions
     *
     * @public
     * @decorator `@bind`
     */
    toOptionsMap<K extends keyof Options<E> & string>(funcMap: Options.FuncMap<Options<E>>, [key, value]: [K & string, Options<E>[K & string]]): Options.FuncMap<Options<E>>;
    /**
     * Get options from function map
     *
     * @public
     * @decorator `@bind`
     */
    fromOptionsMap<K extends keyof Options<E>>(options: Options<E>, [key, value]: [K & string, Options<E>[K & string]]): Options<E>;
    /**
     * Assign properties from an object
     *
     * @public
     * @decorator `@bind`
     */
    fromObject(extensionObject: ExtensionLiteral): this;
    /**
     * Returns true if extension property is set
     *
     * @param key - property name
     * @returns true if property exists on extension
     *
     * @public
     * @decorator `@bind`
     */
    has<K extends `${keyof Extension}`>(key: K): boolean;
    /**
     * Returns true if extension property is set and is a function
     *
     * @param key - property name
     * @returns true if property exists on extension
     *
     * @public
     * @decorator `@bind`
     */
    isFunction<K extends `${keyof Extension}`>(key: K): boolean;
    /**
     * Resolve module using `import.meta.resolve` api
     *
     * @remarks
     * Uses `import-meta-resolve` (npm package).
     * Will transition to node `import.meta.resolve` api when it is marked
     * non-experimental. It currently requires a flag to enable.
     *
     * @public
     * @decorator `@bind`
     */
    resolve(signifier: string, parent?: string): Promise<string>;
    /**
     * Import ESM module
     *
     * @public
     * @decorator `@bind`
     */
    import<T = any>(signifier: string): Promise<T>;
    /**
     * Disable extension
     *
     * @public
     * @decorator `@bind`
     */
    disable(): void;
    /**
     * Enable extension
     *
     * @public
     * @decorator `@bind`
     */
    enable(): void;
    /**
     * Value determining if the extension should be utilized
     *
     * @public
     * @decorator `@bind`
     */
    isEnabled(): Promise<boolean>;
    /**
     * Alias for `.app`
     *
     * @remarks
     * Utility to make it easier to chain config fn calls
     *
     * @public
     * @decorator `@bind`
     */
    done(): Bud;
}
//# sourceMappingURL=index.d.ts.map