import { __decorate } from "tslib";
import { bind } from 'helpful-decorators';
import { has, isBoolean, isFunction, isUndefined } from 'lodash-es';
/**
 * Bud extension
 *
 * @public
 */
export class Extension {
    /**
     * Class constructor
     *
     * @public
     */
    constructor(_app) {
        /**
         * Extension options
         *
         * @internal
         */
        this._options = {};
        /**
         * Extension options
         *
         * @readonly
         * @public
         */
        this.options = {};
        /**
         * Extension meta
         *
         * @public
         */
        this.meta = {};
        this._app = () => _app;
        const logger = _app.logger.makeInstance({
            scope: this.label ?? 'anonymous extension',
        });
        Object.defineProperty(this, 'app', {
            get: () => this._app(),
        });
        Object.defineProperty(this, 'logger', {
            get: () => logger.scope(this.label ?? 'anonymous extension'),
        });
        const opts = this.options;
        Object.defineProperty(this, 'options', {
            get: this.getOptions,
            set: this.setOptions,
        });
        this.setOptions(opts);
    }
    /**
     * `init` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    async _init() {
        if (isUndefined(this.init))
            return;
        await this.app.hooks.fire(`${this.label}/init/before`);
        try {
            await this.init(this.app, this.options);
            this.meta['_init'] = true;
        }
        catch (error) {
            this.logger.error(error);
            this.app.error('error in', this.label);
        }
        await this.app.hooks.fire(`${this.label}/init/after`);
    }
    /**
     * `register` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    async _register() {
        if (isUndefined(this.register))
            return;
        await this.app.hooks.fire(`${this.label}/register/before`);
        try {
            if (this.init && !this.meta['_init'])
                await this._init();
        }
        catch (err) {
            this.logger.error(this.label, 'register => init error', '\n');
        }
        try {
            await this.register(this.app, this.options);
            this.meta['_register'] = true;
        }
        catch (error) {
            this.logger.error('error on register', '\n', error);
            this.app.error('error in', this.label);
        }
        await this.app.hooks.fire(`${this.label}/register/after`);
    }
    /**
     * `boot` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    async _boot() {
        if (isUndefined(this.boot))
            return;
        await this.app.hooks.fire(`${this.label}/boot/before`);
        try {
            if (this.init && !this.meta['_init'])
                await this._init();
            if (this.register && !this.meta['_register'])
                await this._register();
        }
        catch (err) {
            this.logger.error(this.label, 'register => init error', '\n');
        }
        try {
            await this.boot(this.app, this.options);
            this.meta['_boot'] = true;
        }
        catch (error) {
            this.app.error(this.label, 'boot error', '\n', error);
        }
        await this.app.hooks.fire(`${this.label}/boot/after`);
    }
    /**
     * `beforeBuild` callback handler
     *
     * @public
     */
    async _beforeBuild() {
        const enabled = await this.isEnabled();
        if (isUndefined(this.beforeBuild) || enabled === false)
            return;
        await this.app.hooks.fire(`${this.label}/beforeBuild/before`);
        await this.beforeBuild(this.app, this.options);
        await this.app.hooks.fire(`${this.label}/beforeBuild/after`);
    }
    /**
     * `beforeBuild` callback handler
     *
     * @public
     */
    async _afterConfig() {
        const enabled = await this.isEnabled();
        if (isUndefined(this.afterConfig) || enabled === false)
            return;
        await this.app.hooks.fire(`${this.label}/afterConfig/before`);
        await this.afterConfig(this.app, this.options);
        await this.app.hooks.fire(`${this.label}/afterConfig/after`);
    }
    /**
     * `make` callback handler
     *
     * @public
     * @decorator `@bind`
     */
    async _make() {
        const enabled = await this.isEnabled();
        if (enabled === false ||
            (isUndefined(this.make) &&
                isUndefined(this.apply) &&
                isUndefined(this.plugin)))
            return false;
        await this.app.hooks.fire(`${this.label}/make/before`);
        if (this.plugin)
            return new this.plugin(this.options);
        if (this.apply)
            return this;
        try {
            return await this.make(this.app, this.options);
        }
        catch (error) {
            this.app.error(this.label, 'make error', '\n', error);
        }
        await this.app.hooks.fire(`${this.label}/make/after`);
    }
    /**
     * Get extension options
     *
     * @public
     * @decorator `@bind`
     */
    getOptions() {
        return Object.entries(this._options).reduce(this.fromOptionsMap, {});
    }
    /**
     * Set extension options
     *
     * @public
     * @decorator `@bind`
     */
    setOptions(value) {
        this._options = isFunction(value) ? value(this.options) : value;
        return this;
    }
    /**
     * Get extension option
     *
     * @public
     * @decorator `@bind`
     */
    getOption(key) {
        return this.options[key];
    }
    /**
     * Set extension option
     *
     * @public
     * @decorator `@bind`
     */
    setOption(key, value) {
        this._options[key] = isFunction(value)
            ? value(this.options[key])
            : () => value;
        return this;
    }
    /**
     * Normalize options to functions
     *
     * @public
     * @decorator `@bind`
     */
    toOptionsMap(funcMap = {}, [key, value]) {
        return {
            ...funcMap,
            [key]: isFunction(value) ? value : () => value,
        };
    }
    /**
     * Get options from function map
     *
     * @public
     * @decorator `@bind`
     */
    fromOptionsMap(options, [key, value]) {
        return {
            ...(options ?? {}),
            [key]: isFunction(value) ? value(this.app) : value,
        };
    }
    /**
     * Assign properties from an object
     *
     * @public
     * @decorator `@bind`
     */
    fromObject(extensionObject) {
        Object.entries(extensionObject).map(([k, v]) => {
            this[k] = v;
        });
        return this;
    }
    /**
     * Returns true if extension property is set
     *
     * @param key - property name
     * @returns true if property exists on extension
     *
     * @public
     * @decorator `@bind`
     */
    has(key) {
        return has(this, key);
    }
    /**
     * Returns true if extension property is set and is a function
     *
     * @param key - property name
     * @returns true if property exists on extension
     *
     * @public
     * @decorator `@bind`
     */
    isFunction(key) {
        return this.has(key) && isFunction(this[key]) ? true : false;
    }
    /**
     * Resolve module using `import.meta.resolve` api
     *
     * @remarks
     * Uses `import-meta-resolve` (npm package).
     * Will transition to node `import.meta.resolve` api when it is marked
     * non-experimental. It currently requires a flag to enable.
     *
     * @public
     * @decorator `@bind`
     */
    async resolve(signifier, parent) {
        let modulePath;
        modulePath = await this.app.module.resolve(signifier);
        if (!modulePath) {
            modulePath = await this.app.module.resolve(signifier, parent);
        }
        if (!modulePath) {
            this.logger.error('unresolvable:', signifier);
        }
        this.logger.log(signifier, '=>', modulePath.replace(this.app.path(), '.'));
        return modulePath;
    }
    /**
     * Import ESM module
     *
     * @public
     * @decorator `@bind`
     */
    async import(signifier) {
        try {
            const result = await import(signifier);
            this.logger.success('imported', signifier);
            return result?.default ?? result ?? null;
        }
        catch (error) {
            throw new Error(error);
        }
    }
    /**
     * Disable extension
     *
     * @public
     * @decorator `@bind`
     */
    disable() {
        this.when = async () => false;
    }
    /**
     * Enable extension
     *
     * @public
     * @decorator `@bind`
     */
    enable() {
        this.when = async () => true;
    }
    /**
     * Value determining if the extension should be utilized
     *
     * @public
     * @decorator `@bind`
     */
    async isEnabled() {
        if (this.when && isFunction(this.when))
            return await this.when(this.app, this.options);
        if (this.when && isBoolean(this.when))
            return this.when;
        return true;
    }
    /**
     * Alias for `.app`
     *
     * @remarks
     * Utility to make it easier to chain config fn calls
     *
     * @public
     * @decorator `@bind`
     */
    done() {
        return this.app;
    }
}
__decorate([
    bind
], Extension.prototype, "_init", null);
__decorate([
    bind
], Extension.prototype, "_register", null);
__decorate([
    bind
], Extension.prototype, "_boot", null);
__decorate([
    bind
], Extension.prototype, "_beforeBuild", null);
__decorate([
    bind
], Extension.prototype, "_afterConfig", null);
__decorate([
    bind
], Extension.prototype, "_make", null);
__decorate([
    bind
], Extension.prototype, "getOptions", null);
__decorate([
    bind
], Extension.prototype, "setOptions", null);
__decorate([
    bind
], Extension.prototype, "getOption", null);
__decorate([
    bind
], Extension.prototype, "setOption", null);
__decorate([
    bind
], Extension.prototype, "toOptionsMap", null);
__decorate([
    bind
], Extension.prototype, "fromOptionsMap", null);
__decorate([
    bind
], Extension.prototype, "fromObject", null);
__decorate([
    bind
], Extension.prototype, "has", null);
__decorate([
    bind
], Extension.prototype, "isFunction", null);
__decorate([
    bind
], Extension.prototype, "resolve", null);
__decorate([
    bind
], Extension.prototype, "import", null);
__decorate([
    bind
], Extension.prototype, "disable", null);
__decorate([
    bind
], Extension.prototype, "enable", null);
__decorate([
    bind
], Extension.prototype, "isEnabled", null);
__decorate([
    bind
], Extension.prototype, "done", null);
//# sourceMappingURL=index.js.map